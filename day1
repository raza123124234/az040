 get-childitem
 Get-Process
  Get-Service
  Get-EventLog -LogName System

  Get-EventLog -LogName System -Newest 10

  Get-Location
Get-LocalUser


 Set-Date -Date "2025-09-01"

 Set-Date -Date "2025-09-01 12:47AM"
 
Set-Variable -name city -value "Melbourne"

$PSVersionTable

 Set-Service -name dhcp -StartupType Disable

 get-help Set-Service -examples
  Start-Service -name 

  Stop-Service -name

  Set-Content -path "C:\users\admin10\1.txt" -Value "xyz"

  Get-Content -path "C:\users\admin10\1.txt"


  New-Item -path  "C:\users\admin10\2.txt"  -ItemType File


remove-item "C:\users\admin10\2.txt"

stop-process -name notepad
   
get-help Set-Service -examples


get-command *ipv4*


$Env:PSModulePath



Install-Module -Name PowerShellGet -Force

 Install-Module -Name Az -Repository PSGallery -Force

 import-module Az
  import-module dnsclient
  import-module netsecurity

 get-module -listavailable -name Az*


 find-command get-process


 dir

 cd set-location 

 mkdir new-item

 get-content  -path "C:\users\admin10\1.txt"

 remote-item del

 cls clear-host
  set-alias GP1  get-process  -force

   remove-item alias:GP1

   Get-Alias

   rename-computer -NewName "DC1" -Restart

 Install-WindowsFeature -Name AD-Domain-Services -IncludeManagementTools 

Install-ADDSForest -DomainName logitrain.local -ForestMode Win2012 -DomainMode Win2012 -InstallDns:$true -SafeModeAdministratorPassword (ConvertTo-SecureString "L@gi12341234" -AsPlainText -force)



New-ADOrganizationalUnit -name IT 

New-ADOrganizationalUnit -name IT -path "DC=logitrain,DC=local"

New-aduser -name "Dave John" -GivenName "Dave" -Surname "John" -SamAccountName "DaveJohn" -UserPrincipalName "DJ@logitrain.local" 
-Enabled $true -AccountPassword (ConvertTo-SecureString "L@gi12341234" -AsPlainText -force) -path "OU=IT,DC=logitrain,DC=local"]

 New-ADGroup -name support -GroupCategory Security -GroupScope Global -Path "OU=IT,DC=logitrain,DC=local"



 Set-ADAccountPassword -Identity "DaveJohn"  -NewPassword (ConvertTo-SecureString "L@gi12341234" -AsPlainText -force) -reset



  Get-Aduser -Filter * | select-object SamAccountName


   Get-Aduser -Filter *

    Get-Aduser -Filter * | Select-Object samaccountname,Givenname, enabled



   
  Get-Aduser -Filter * -Searchbase "OU=IT,DC=logitrain,DC=local" | select-object name


  Get-Adgroupmember -Identity "Support"

  Add-ADGroupMember -Identity "support" -Members "DaveJohn"

  Get-Adgroupmember -Identity "Support"

   new-Adcomputer -name "PC01" -path "OU=IT,DC=logitrain,DC=local" -enabled $true


    set-adcomputer -Identity "PC01" -Description "IT dept"


    get-adcomputer -Identity "PC01"


    get-adcomputer -Identity "PC01" -Properties * 



    Get-ADOrganizationalUnit -Filter *



    Get-Dnsclient 
    Get-Dnsclientserveraddress
    Set-NetFirewallProfile -profile domain,private, public -enabled false



     New-NetFirewallRule -name httpallow -Direction inbound -Protocol tcp -LocalPort 80 -Action Allow
     Get-NetFirewallRule 

      Get-NetFirewallRule  -DisplayName "httpallow"

       Get-NetFirewallRule -Action Allow 


      Set-NetFirewallRule -DisplayName "httpallow" -Enabled

      Enable-NetFirewallRule -DisplayName "httpallow"
      Disable-NetFirewallRule -DisplayName "httpallow"



      New-GPO -Name "dontchangetheme"
       New-GPLink -name "dontchangetheme" -target "OU=IT,DC=logitrain,DC=local"
       Set-GPRegistryValue -Name "dontchangetheme" -Key "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer" -ValueName "noDispCPL"  -Type DWord -Value 1
        gpupdate /force
    gpresult /r

    New-VM -Name "VM2" -MemoryStartupBytes 2GB -Generation 2 -Path "D:\VMs"

Start-VM -Name "VM1"

Stop-VM -Name "VM1" -Force

Restart-VM -Name "VM1"

Suspend-VM -Name "VM2"

Resume-VM -Name "VM2"

Import-VM -Path "D:\VMs\VM2\VM2.xml"

Export-VM -Name "VM2" -Path "D:\VMExports"


 Install-WindowsFeature -name Web-server -IncludeManagementTools

get-windowsfeature



get-computerinfo | select-object  Osname





 $info = get-computerinfo

write-host "--------system information------------"

Write-Host "OS Name : $($info.OsName)"

Write-Host "OS Status :$($info.OSstatus)"



 Get-EventLog -LogName Security -Newest 10


 Clear-EventLog -LogName system

  Get-EventLog -LogName System -Newest 10





$Acl = Get-Acl -Path "C:\test"  

  $permission = "logitrain.local\admin10","FullControl","Allow"

  $accessrule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission

  $Acl.SetAccessRule($accessrule)

  set-acl -Path "C:\test" -AclObject $Acl


 get-service | Where-Object {$_.status -eq "Running"}

 get-process | Where-Object {$_.WorkingSet -gt 100MB}

 get-process | Where-Object {$_.WorkingSet -gt 100MB} | Select-Object ProcessName, ID, CPU

 Get-ChildItem "C:/" | Where-Object {-not $_.VersionInfo}  | Get-Member

 Get-ChildItem "C:/" | Where-Object {$_.Extension -eq ".txt"}

  Get-ChildItem "C:/" | Where-Object {$_.Extension -eq ".exe" -or $_.length -le 10MB } 

    Get-ChildItem "C:/" | Where-Object {$_.name -eq ".exe"  } 

    Get-ChildItem "C:/" | Where-Object {$_.name -notlike "*.*"  }

    Get-ChildItem "C:/" | Where-Object {$_.Attributes -match "Hidden"  }


    get-service | format-list 

        get-service | format-list -Property displayname, status


        get-aduser | format-list -Property name, sid

         get-aduser -Filter * | Where-Object {$env:USERDOMAIN_ROAMINGPROFILE} | get-member

          Get-ADuser -Filter * -Properties Name | ft -Property Name

          Get-ADuser -Filter * -Properties Name | ft -Property Name,surname

          Get-ADComputer -Filter * -Properties OperatingSystem | ft -Property Name, OperatingSystem


          Get-ADComputer -Filter * | ft -Property Name, OperatingSystem

          Get-ADuser -Filter * -Properties Name | ft -Property Name,surname,EmailAddress, enabled


          get-service  | sort-object Name -Descending


          get-process | Sort-Object CPU -Descending | Select-Object -first 10


          get-service  | Group-Object Status  
          
          
          get-service  | Group-Object ServiceType   
          
           140 Get-ChildItem C:/  | sortobject   
                                                                                                    
          Get-ChildItem C:/  | Sort-Object                                                                                           
          
          Get-ChildItem C:/  | Sort-Object -Descending                                                                               
          
          Get-ChildItem C:/  | Sort-Object Size -Descending                                                                          
   

   get-process | Sort-Object -Property processname


   Get-ChildItem C:/ | Measure-Object

   Get-ChildItem C:/ | Measure-Object -Property Length -Maximum


   Get-ChildItem C:/ | Measure-Object -Property Length -Maximum

   Get-ChildItem C:/ | Measure-Object -Property Length -Minimum

   Get-ChildItem C:/ | Measure-Object -Property length -Sum -Maximum -Minimum -Average


   get-date | Select-Object -Property DayOfYear


   get-date | Select-Object -Property Hour


   Get-EventLog –Newest 10 –LogName Security | Select-Object –Property EventID,TimeWritten,Message



   Get-Volume | Select-Object -Property DriveLetter,

@{n='Size(GB)'; e={ '{0:N5}' -f ($PSItem.Size / 1MB) }},

@{n='FreeSpace(GB)'; e={ '{0:N3}' -f ($PSItem.SizeRemaining / 1MB) }}



Get-Service | Where Status –eq Running

Get-Process | Where CPU –gt 20


Get-Service | Where-Object –Filter {$PSItem.Status -like "*Run*"}


Get-service | Where { $_.Status -eq "Running"}


Get-service | ? { $_.Status -eq "Running"}

Get-Volume | Where-Object –Filter{ $PSItem.HealthStatus –ne 'Healthy'-or
  $PSItem.SizeRemaining –lt 100MB
}


Get-ChildItem "C:/" | Where-Object {$_.Extension -eq ".exe" -or $_.length -le 10MB }



New-EventLog -LogName Application -Source "MyPSAlerts"


Get-Volume | Where-Object {
    $_.HealthStatus -ne 'Healthy' -or $_.SizeRemaining -lt 100MB
} | ForEach-Object {
    Write-EventLog -LogName Application `
                   -Source "PSAlerts" `
                   -EntryType Warning `
                   -EventId 2001 `
                   -Message "DriveAlert: $($_.DriveLetter)"




 get-service | foreach Name  

 Get-Service   

 Get-EventLog -list 

 Get-EventLog -list | where log -in @("System","Application") 

 get-process > C:1.txt


  get-process >> C:1.txt

  get-process | ConvertTo-Json | out-file C:\2.json


  get-process | ConvertTo-html | out-file C:\2.json

  get-aduser -filter * -Properties Name,Enabled | select-object Name, SiD, Enabled | ConvertTo-html -Title "AD Users" 



  Get-PSProvider                                                                                                                  
   2 import-module ActiveDirectory                                                                                                   
   3 Get-PSProvider                                                                                                                  
   4 Get-Help about_FileSystem_Provider                                                                                              
   5 Import-Module DnsServer                                                                                                         
   6 Get-PSProvider                                                                                                                  
   7 Get-Module -ListAvailable                                                                                                       


   Get-Command *-Item,*-ItemProperty

   Get-Item -Path "HKLM:\SYSTEM"


   Get-ChildItem Alias:

   New-Item -path Alias:np -Value "Notepad.exe"

   Remove-Item Alias:np


   Get-ChildItem Alias:

   New-Item -Path Env:xyzvar -value xyz

   remove-item Env:windir


   New-Item -Path C:\powershellfolder -ItemType Directory 

   New-Item -Path C:\powershellfolder\file1.txt -ItemType File

   set-content -path  C:\powershellfolder\file1.txt -Value "lsmmdclndslcn"

   get-content -path  C:\powershellfolder\file1.txt 

   remote-item -path  C:\powershellfolder\file1.txt



   Function hello  { Write-Output "hello" }                                                                                        
   hello                                                                                                                           
  new-item function: abc                                                                                                          
  new-item -path function:\abc -value {"abc"}                                                                                     


  Get-ChildItem Function:

   Function hello  { Write-Output "hello" }

   remote-item Function: hello




   Get-ChildItem variable:

   Get-Variable

    Set-Variable x -Value "logitrain"

     Get-Variable x


     New-Item -Path HKCU:\Software\ -name demovalue -Value "123" 

     New-ItemProperty -Path HKCU:\Software -name "demovalue" -Value "1234" -PropertyType string

      Copy-Item -Path C:\1.txt -Destination C:\2.txt

      Clear-Content

       Copy-Item -Path HKCU:\Software\demovalue -Destination HKCU:\Software\demovalue2

      Move-Item -Path HKCU:\Software\demovalue -Destination HKCU:\Software\demovalue2

      rename-item -Path C:\1.txt -newname C:\2.txt

      rename-item -Path HKCU:\Software\demovalue -newname HKCU:\Software\demo1value2

       Invoke-item -Path C:\1.txt

       notepad.exe  C:\1.txt   


        Get-CimInstance -ClassName Win32_Account


        
        Get-CimInstance -ClassName Win32_Account -ComputerName vm2

        Get-CimInstance -ClassName Win32_OperatingSystem

         Get-CimInstance -ClassName Win32_OperatingSystem | Select CSName,version,OperatingSystemSKU,BuildType

          $session = New-CimSession -ComputerName vm2 

          Get-CimInstance -ClassName Win32_Account -ComputerName  $session


           Get-CimInstance -ClassName Win32_OperatingSystem -Namespace 


           Get-CimInstance -ClassName Win32_OperatingSystem -Namespace root/InventoryLogging wrong



           Get-CimClass -Namespace root/CIMV2 | select-object cimclassname


           Get-CimInstance -ClassName Win32_BIOS | Select-Object -Property Name, SoftwareElementID, SoftwareElementState, TargetOperatingSystem, BIOSVersion

           Get-WmiObject -Namespace root -List -Recurse | Select -Unique __NAMESPACE

           Get-WmiObject -Namespace root\CIMv2 -List

           Get-CimClass -Namespace root\CIMv2


            Get-CimClass  *network*


            Get-CimInstance -ClassName Win32_BIOS

            Get-WmiObject -Class Win32_LogicalDisk


            Get-CimInstance -ClassName Win32_Process 

            Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DriveType=3" 


            Get-CimClass -Class Win32_Service | Select-Object -ExpandProperty CimClassMethods

             Get-CimInstance -Query "SELECT * FROM Win32_NetworkAdapter"

             $username = "abcd"
             $email = "$username@company.com"

              $date = (get-date).AddDays(15)

              $process = get-process -name cmd

              $num1 = 5
$logFile = “C:\Logs\Log.txt”
$user = Get-ADUser Administrator
$service = Get-Service W32Time


[int32]$num1 = 100

[double]$num1 = 100.10

[datetime]$num1 = get-date

[bool]$Active = $true


[bool]$disable = $false




$service = Get-Service W32Time 
To display the value of $service, enter the following command, and then select Enter:
$service 
To display $logFile as part of a text message on screen, enter the following command, and then select Enter:
Write-Host "The log file location is $logFile" 
To review all of the properties of the service object stored in $service, enter the following command, and then select Enter:
$service | Format-List * 
To review the Status property of $service, enter the following command, and then select Enter:
$service.status 
To review the Name and Status properties of $service, enter the following command, and then select Enter:
$service | Format-Table Name,Status 

$text = "Powershell"
$text.length
$text.Contains("shell")
 $text.ToLower()

 $text.Split("")


  $machines = "vm1","vm2","vm3"

  $machines[0]

  $machines[1]

  $machines[2]

   $machines[2] = "virtualpc3"


   $servers = @("8.8.8.8","1.1.1.1","8.8.3.4")

foreach ($ip in $Servers) {
        Write-Output "pinging $ip"
        Test-Connection -ComputerName $ip -count 2 -quiet
        
        }





        $targets = @(
        @{host="google.com";port= 80},
        @{host="google.com";port= 443}
        )

        
foreach ($t in $targets) {
        Write-Output "pinging $t.host"
        Test-netConnection -ComputerName $t.host -Port $t.port
        
        }



        $host1 = Read-Host "Enter hostname or IP"
$port1 = Read-Host "Enter port number"

 $result = Test-netConnection -ComputerName $host1 -Port $port1

 if ($result.TcpTestSucceeded) {
    Write-Output " open"
    }
    else 
    {
    Write-Output "closed"
    } 



 write-host "select an action"

write-host "1 - check service status"
write-host "2 - start service"
write-host "3 - stop service"
write-host "4 - exit"

$choice = read-host "enter your choice (1 to 4)"
if ($choice -in 1,2,3){
       $servicename = read-host "enter the service name for exampler spooler chrome"
      }

Switch($choice){
    "1"
    {
       get-service -name $servicename 
       } 
       
       }

Switch($choice){
    "2"
    {
       start-service -name $servicename 
       } 
       
       }



       $sourceFolder ="C:\test"

       $backupFolder ="C:\backup"














    





    
          $sourceFolder ="C:\test\*"

       $backupFolder ="C:\backup"

     


       if ( -not  (Test-Path $backupFolder))
       {
       New-Item -ItemType Directory -Path $backupFolder
       }


      do{
      $files =  @(Get-ChildItem  -Path $sourceFolder -File)

      if($files.Count -gt 0){



      

       foreach($file in $files){



      Move-Item -Path $sourceFolder -Destination $backupFolder -Force
        Write-Output  "moved $($file.Name)"

       }
       }
       }
       
        while ($files.Count -gt 0)















        Continue stops processing the current iteration of a loop:


ForEach ($user in $users) {     If ($user.Name -eq “Administrator”) {Continue}     Write-Host “Modify user object”}
Break completely stops loop processing:
ForEach ($user in $users) {     $number++     Write-Host “Modify User object $number”     If ($number -ge $max) {Break}}



Get-Content retrieves content from a text file.
Each line in the file becomes an item in an array:

$computers = Get-Content "C:\Scripts\computers.txt" 

Import multiple files by using wildcards:

Get-Content -Path "C:\Scripts\*" -Include "*.txt","*.log"

Limit the data retrieved by using the -TotalCount and -Tail parameters.



$computers = Get-Content "C:\Scripts\computers.txt" -tail 100




The first row in the CSV file is a header row.
Each line in the CSV file becomes an array item.
The header row defines the property names for the items:


$users = Import-Csv C:\Scripts\Users.csv

You can specify a custom delimiter by using the -Delimiter parameter.

You can specify a missing header row by using the -Header parameter.





XML can store more complex data than CSV files.
Import-Clixml creates an array of objects:
$users = Import-Clixml C:\Scripts\Users.xml
Use Get-Member to review object properties.
Limit the data retrieved by using the -First and -Skip parameters.



JSON is:
A lightweight data format similar to XML.
Commonly used by web services.
You can convert from JSON, but not import directly.
$users = Get-Content C:\Scripts\Users.json | ConvertFrom-Json
Retrieve JSON data directly from web services by using Invoke-RestMethod.
$users = Invoke-RestMethod "https://hr.adatum.com/api/staff"


Invoke-RestMethod "https://microsoftedge.github.io/Demos/json-dummy-data/64KB.json"



$password = read-host "Enter your password" -


$cred = Get-Credential -Message "updating passowrd" -UserName "logitrain.local\Administrator"

Set-ADUser -UserPrincipalName "administrator@logitrain.local" -Credential $cred


$selection = $users | Out-GridView -PassThru 


 Start-Sleep -Seconds 2





 

param (
    [string]$Computer = "Server01",
    [switch]$TestMode
)

# Enable debug and verbose streams if TestMode is set
if ($TestMode) {
    $DebugPreference = "Continue"
    $VerbosePreference = "Continue"
}

Write-Verbose "Starting the script. Target computer: $Computer"
Write-Debug "Debug info: TestMode is $TestMode"

# Example variable to watch
$Status = "Initializing"

Write-Verbose "Status before processing: $Status"
Write-Debug "Current computer variable: $Computer"

# Simulate some processing
$Status = "Processing"
Write-Verbose "Status updated: $Status"
Write-Debug "Performing some operation on $Computer"

# Simulate operation
Start-Sleep -Seconds 2

# Finalize
$Status = "Completed"
Write-Verbose "Status after processing: $Status"
Write-Debug "Script completed for $Computer"

# Example breakpoints you can set in PowerShell
# 1. Line breakpoint (pause at a specific line)
# Set-PSBreakPoint -Line 18 -Script "MyScript.ps1"

# 2. Command breakpoint (pause when a specific command is run)
# Set-PSBreakPoint -Command "Start-Sleep" -Script "MyScript.ps1"

# 3. Variable breakpoint (pause when variable is read or written)
# Set-PSBreakPoint -Variable "Status" -Mode ReadWrite -Script "MyScript.ps1"

# Example action with a breakpoint
# Set-PSBreakPoint -Line 20 -Script "MyScript.ps1" -Action {
#     Write-Host "Breakpoint hit! Current Status: $Status"
#     $Status = "Paused for review"
# }

# End of script




$ErrorActionPreference defines what happens for non-terminating errors:
Continue
SilentlyContinue
Inquire
Stop
It’s preferred to modify the error action for individual commands rather than globally:
Get-WmiObject -Class Win32_BIOS -ComputerName LON-SVR1,LON-DC1 -ErrorAction Stop
Set the error action globally when it can’t be done at the command:
For example, using methods on an object







function Fun1 {
    param(
    $name = "dfvdfv"
    
    )

    Write-Output "$name"



}

function add-numbers{

    param(
    
           $A,
           $B
            )


            return $A + $B


}

add-numbers -A 10 -B 20 



Enable-PSRemoting -Force  # enable it on remote pc 
#run on local server to access remote pc

Set-Item WSMan:\localhost\Client\TrustedHosts -Value "10.1.0.5"

Test-WSMan 10.1.0.5

Enter-PSSession -ComputerName 10.1.0.5  -Credential (Get-Credential)




Invoke-Command
  -ScriptBlock { 
    get-service
     }
  -ComputerName 10.1.0.5
  -ArgumentList (Get-Credential),'path'


  Invoke-Command -ComputerName 10.1.0.5 -Credential (Get-Credential) -ScriptBlock { Get-Service }


  $dc = New-PSSession –ComputerName LON-DC1 -Credential (Get-Credential)

  Disconnect-PSSession –Session $dc

  Get-PSSession –ComputerName 10.1.0.5 -Credential (Get-Credential)


  import implicit

  $session = New-PSSession -ComputerName 10.1.0.5 -Credential (Get-Credential)
  Import-PSSession -Session $session -Module ActiveDirectory
   Connect-AzAccount 
   get-azvm
   Get-AzResourcegroup 



   You can install the Azure Az PowerShell module by using one of the following methods:
The Install-Module cmdlet
Azure PowerShell MSI
Az PowerShell Docker container

To install the Az module, run the following command:
	Install-Module -Name Az -Scope CurrentUser -Repository PSGallery –Force

To sign in to Azure from Azure PowerShell, run the following command:
	Connect-AzAccount


Automatic migration is the recommended option for migrating from AzureRM to the Az PowerShell module.
Install the AzureRM to Az migration toolkit by using the following command:
	Install-Module -Name Az.Tools.Migration

To install Azure Active Directory Module for Windows PowerShell, use the following command:
	Install-Module MSOnline
To install Azure Active Directory PowerShell for Graph, use the following command:
	Install-Module AzureAD or Install-module AzureADPreview




new-azvm -ResourceGroupName az040 -Name 'PC1-vm' -Location 'Australia East' -Image Win2016Datacenter -VirtualNetworkName  admin10-vnet 
-SubnetName default -SecurityGroupName admin10-nsg 



 New-AzStorageAccount -ResourceGroupName az040 -name logitrainstorage123 -location 'australia east' -kind storagev2 -SkuName Standard_LRS -MinimumTlsVersion TLS1_2


 New-AzADuser -DisplayName 'dave' -GivenName 'dave' -Surname "john" -UserPrincipalName 'd@logitrain9999outlook.onmicrosoft.com' -UsageLocation 'Au'  -AccountEnabled $true


  Get-AzADUser -ObjectId 'd@logitrain9999outlook.onmicrosoft.com'


  set-AzADUser -ObjectId 'd@logitrain9999outlook.onmicrosoft.com' -Department 'administrators'


  remove-AzADUser -ObjectId 'd@logitrain9999outlook.onmicrosoft.com'


  get-azadgroup



  $UserPassword=New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile
$UserPassword.Password="Pa55w.rd"
New-AzureADUser -DisplayName "Abbie Parsons" -GivenName "Abbie" -SurName "Parsons" -UserPrincipalName AbbieP@adatum.com -UsageLocation US -PasswordProfile $UserPassword -AccountEnabled $true -MailNickName 'abbie
'

Get-AzureADUser -ObjectId AbbieP@adatum.com


Get-AzureADUser -All $true


New-MsolUser -DisplayName "Abbie Parsons" -FirstName "Abbie" -LastName "Parsons" -UserPrincipalName AbbieP@adatum.com -Password "Pa55w.rd"

Get-MsolUser -UserPrincipalName AbbieP@adatum.com''


Get-MsolUser -All
 

 New-AzureADGroup -DisplayName "Marketing Group" -MailNickname MarketingGrp


 $roleTemplate = Get-AzureADDirectoryRoleTemplate | Where {$_.displayName -eq 'User Administrator'}
Enable-AzureADDirectoryRole -RoleTemplateId $roleTemplate.ObjectId


$user = Get-AzureADUser -ObjectID AbbieP@adatum.com
$role = Get-AzureADDirectoryRole | Where {$_.displayName -eq 'User Administrator'}
Add-AzureADDirectoryRoleMember -ObjectId $role.ObjectId -RefObjectId $user.ObjectID


Add-MsolRoleMember -RoleMemberEmailAddress AbbieP@adatum.com -RoleName 'User Administrator'

 Get-AzureADSubscribedSku


$License = New-Object -TypeName Microsoft.Open.AzureAD.Model.AssignedLicense
$License.SkuId = '05e9a617-0261-4cee-bb44-138d3ef5d965'
$LicensesToAssign = New-Object -TypeName Microsoft.Open.AzureAD.Model.AssignedLicenses
$LicensesToAssign.AddLicenses = $License
Set-AzureADUserLicense -ObjectId AbbieP@adatum.com -AssignedLicenses $LicensesToAssign


$License.DisabledPlans = '7547a3fe-08ee-4ccb-b430-5077c5041653'
$License.DisabledPlans.Add('a23b959c-7ce8-4e57-9140-b90eb88a9e97')


$License = New-Object -TypeName Microsoft.Open.AzureAD.Model.AssignedLicense
$License.SkuId = '05e9a617-0261-4cee-bb44-138d3ef5d965'
$LicensesToAssign = New-Object -TypeName Microsoft.Open.AzureAD.Model.AssignedLicenses
$LicensesToAssign.RemoveLicenses = $License
Set-AzureADUserLicense -ObjectId AbbieP@adatum.com -AssignedLicenses $LicensesToAssign



To review available licenses by using AzureAD:
Get-AzureADSubscribedSku | Select-Object -Property Sku*,ConsumedUnits -ExpandProperty PrepaidUnits
To assign licenses to a user by using AzureAD:
$License = New-Object -TypeName Microsoft.Open.AzureAD.Model.AssignedLicense
$License.SkuId = '05e9a617-0261-4cee-bb44-138d3ef5d965'
$LicensesToAssign = New-Object -TypeName Microsoft.Open.AzureAD.Model.AssignedLicenses
$LicensesToAssign.AddLicenses = $License
Set-AzureADUserLicense -ObjectId AbbieP@adatum.com -AssignedLicenses $LicensesToAssign
To disable specific service plans by using AzureAD:
$License.DisabledPlans = '7547a3fe-08ee-4ccb-b430-5077c5041653'
$License.DisabledPlans.Add('a23b959c-7ce8-4e57-9140-b90eb88a9e97')

\\\To install the Exchange Online module:
Install-Module -Name ExchangeOnlineManagement
Scripts must be enabled
Basic authentication must be allowed for the WinRM client
To connect to Exchange Online:


$ProxyOptions = New-PSSessionOption -ProxyAccessType IEConfig
Connect-ExchangeOnline -PsSessionOption $ProxyOptions



Example: Create a shared mailbox
New-Mailbox -Shared -Name "Marketing Team" -DisplayName "Marketing Team" -Alias "MarketingTeam"

Forwarding emails to another mailbox while retaining copies in the original mailbox:
"DoraM@adatum.com" `
    -DeliverToSet-Mailbox -Identity "AbbieP@adatum.com" `
    -ForwardingSmtpAddress MailboxAndForward $true
-ForwardingSmtpAddress → address to forward emails to.
-DeliverToMailboxAndForward $true → keeps a copy in the original mailbox.




Get-EXOMailbox -Identity "AbbieP@adatum.com" | Format-List *



Mailbox Permissions (full access, send-as, send-on-behalf):
# Grant full access to another user
Add-MailboxPermission -Identity "AbbieP@adatum.com" -User "DoraM@adatum.com" -AccessRights FullAccess -InheritanceType All


2. Assign a Delegate to a Resource Mailbox
# Assign AbbieP@adatum.com as a delegate for the BoardRoom resource mailbox
Set-CalendarProcessing -Identity "BoardRoom" -ResourceDelegates "AbbieP@adatum.com"
-Identity → the resource mailbox name (e.g., BoardRoom).
-ResourceDelegates → user(s) who will approve/decline meeting requests.\\\




2. Add a User to an Exchange Online Role
# Add a user to the Recipient Management role
Add-RoleGroupMember -Identity "Recipient Management" -Member "AbbieP@adatum.com"
# -Identity → Name of the role group. -Member → User’s UPN or alias to be added.


To install SharePoint Online Management Shell:

Install-Module -Name Microsoft.Online.SharePoint.PowerShell
To update SharePoint Online Management Shell:

Update-Module -Name Microsoft.Online.SharePoint.PowerShell

To connect to SharePoint Online:
Connect-SPOService -Url https://yourtenant-admin.sharepoint.com




2. Create a SharePoint Group
New-SPOSiteGroup `
    -Group "MarketingUsers" `
    -PermissionLevels "Read" `
    -Site "https://adatum.sharepoint.com/sites/Marketing"



    Add-SPOUser `
    -Site "https://adatum.sharepoint.com/sites/Marketing" `
    -Group "MarketingUsers" `
    -LoginName "AbbieP@adatum.com"
-LoginName → UPN of the Azure AD user.



. Create a SharePoint Site
New-SPOSite `
    -Url "https://adatum.sharepoint.com/sites/Marketing" `
    -Owner "AbbieP@adatum.com" `
    -StorageQuota 256  #MB


    Set-SPOSite `
    -Identity "https://adatum.sharepoint.com/sites/Marketing" `
    -Title "Marketing Portal"


   Review Site Configuration
Get-SPOSite -Identity "https://adatum.sharepoint.com/sites/Marketing" | Format-List


Configure Sharing for a Site
Set-SPOSite `
    -Identity "https://adatum.sharepoint.com/sites/Marketing" `
    -SharingCapability Disabled
Parameters:
-Identity → URL of the SharePoint site.
-SharingCapability → controls how content can be shared.

Valid values for SharingCapability are:
ExternalUserAndGuestSharing
ExternalUserSharingOnly
ExistingExternalUserSharingOnly
Disabled

Other Parameters Affecting Sharing
-LockState → Locks the site to prevent edits (Unlock, NoAccess, ReadOnly).
-SharingDomainRestrictionMode → Restrict sharing to specific domains.
-DefaultSharingLinkType → Default link type for sharing (Direct, Internal, AnonymousAccess).
-DefaultLinkPermission → Default permission for shared links (View, Edit).
-GuestSharingEmailAllowed → Controls if guest invitations can be sent via email.



Start-Job -ScriptBlock { Dir C:\ -Recurse } -Name LocalDirectory
Start-Job -FilePath C:\test.ps1 -Name TestScript


Invoke-Command -ScriptBlock { Get-EventLog -LogName System -Newest 10 } `
-ComputerName LON-DC1,LON-CL1,LON-SVR1 -AsJob -JobName RemoteLogs


Start-Job -ScriptBlock { Get-CimInstance -ClassName Win32_ComputerSystem }


Get-WmiObject -Class Win32_NTEventLogFile -ComputerName localhost,LON-DC1 -AsJob


Get-Job –ID <parent_ID> -IncludeChildJobs

List all jobs:
Get-Job
Retrieve a specific job by ID:
Get-Job -Id <JobId>
Retrieve a specific job by Name:
Get-Job -Name "<JobName>"



Working with Child Jobs
Some jobs, especially remote jobs or CIM/WMI jobs, can spawn child jobs.
To include child jobs in the output:
Get-Job -Id <ParentJobId> -IncludeChildJobs
Child jobs run independently but are linked to the parent job.

Retrieves the output of a completed job.
By default, results are removed from memory once retrieved unless you use -Keep.

2. Syntax Examples
Pipe jobs directly to Receive-Job:
Get-Job | Receive-Job
Retrieve results by Job ID:
Receive-Job -Id <JobId>
Retrieve results by Job Name:
Receive-Job -Name "<JobName>"
Keep results in memory for later retrieval:
Receive-Job -Id <JobId> -Keep

3. Handling Parent and Child Jobs
If the job is a parent job with child jobs (common in remote or CIM jobs):
Receive-Job -Id <ParentJobId> -Keep
Receiving results from a parent job automatically includes results from all child jobs.

4. Example Workflow
# Start a remote job that generates child jobs
$job = Invoke-Command -ComputerName LON-DC1 -ScriptBlock { Get-Service } -AsJob

# Wait for the job to complete
Wait-Job -Id $job.Id

# Retrieve results and keep them in memory
Receive-Job -Id $job.Id -Keep

# Retrieve results again if needed
Receive-Job -Id $job.Id






get-job 

$localjob = start-job -ScriptBlock {get-childitem C:\windows}

get-job -id $localjob.Id

Stop-Job -Id $localJob.Id

 Wait for the job to complete before retrieving results

Wait-Job -Id $localJob.Id

Get the output from the local job

Receive-Job -Id $localJob.Id

Remove-Job -Id $localJob.Id




On LON-CL1, open the Windows PowerShell ISE as Administrator.
Enter the following command, and then select Enter: 
	Enable-PSRemoting
Note: An error may occur when performing Enable-PSRemoting that refers to the network connection type is set to public. If this happens, the network adapter on LON-CL1 should be disabled and then re-enabled to ensure that the connection type is set to Domain.
Enter the following command, and then select Enter:
	Start-Job –ScriptBlock { Dir C:\ -Recurse } –Name LocalDir
Enter the following command, and then select Enter:
	Invoke-Command –ScriptBlock { Get-EventLog –LogName Security –Newest 100 } –ComputerName 
	LON-CL1,LON-DC1 –JobName RemoteLogs
Enter the following command, and then select Enter:
	Get-Job
Enter the following command, and then select Enter:
	Get-Job –Name LocalDir | Stop-Job



Get-Job | Remove-Job
Note: You might notice an error here stating that the directory name C:\Users\.....\PowerShell\ScheduledJobs is invalid. This will display if there are no defined scheduled jobs and is expected. You run the Remove-Job command here to clear the jobs before proceeding with the next steps.
2. Enter the following command, and then select Enter:
$trigger = New-JobTrigger –Once –At (Get-Date).AddMinutes(2)
3. Enter the following command, and then select Enter:
Register-ScheduledJob –Trigger $trigger –Name DemoJob –ScriptBlock { Get-EventLog –LogName Application }
4. Enter the following command, and then select Enter:
Get-ScheduledJob | Select –Expand JobTriggers 
Note: Notice the Time.
5. Enter the following command, and then select Enter:
Get-ScheduledJob 
6. Enter the following command, and then select Enter:
Get-Job
7. Enter the following command, and then select Enter:
Receive-Job –Name DemoJob
8. Enter the following command, and then select Enter:
Get-Job –Name DemoJob | Remove-Job







